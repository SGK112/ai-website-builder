import crypto from 'crypto'

interface EnvVariable {
  key: string
  value: string
  isSecret: boolean
}

type ProjectType = 'business-portfolio' | 'ecommerce' | 'saas'

export function generateEnvVariables(options: {
  projectName: string
  projectType: ProjectType
  customVars?: Record<string, string>
}): EnvVariable[] {
  const { projectName, projectType, customVars = {} } = options
  const variables: EnvVariable[] = []

  // Base variables
  variables.push(
    { key: 'NODE_ENV', value: 'production', isSecret: false },
    { key: 'NEXT_PUBLIC_APP_NAME', value: projectName, isSecret: false },
    { key: 'NEXTAUTH_SECRET', value: generateSecureSecret(), isSecret: true },
    { key: 'NEXTAUTH_URL', value: '${RENDER_EXTERNAL_URL}', isSecret: false }
  )

  // Type-specific variables
  if (projectType === 'ecommerce' || projectType === 'saas') {
    variables.push(
      { key: 'STRIPE_SECRET_KEY', value: '', isSecret: true },
      { key: 'STRIPE_PUBLISHABLE_KEY', value: '', isSecret: false },
      { key: 'STRIPE_WEBHOOK_SECRET', value: '', isSecret: true }
    )
  }

  if (projectType === 'saas') {
    variables.push(
      { key: 'MONGODB_URI', value: '', isSecret: true },
      { key: 'JWT_SECRET', value: generateSecureSecret(), isSecret: true }
    )
  }

  // Add custom variables
  for (const [key, value] of Object.entries(customVars)) {
    variables.push({
      key,
      value,
      isSecret: isSecretKey(key),
    })
  }

  return variables
}

export function generateEnvFile(
  variables: EnvVariable[],
  options: { includeSecrets?: boolean } = {}
): string {
  const { includeSecrets = false } = options

  const lines = variables
    .filter((v) => includeSecrets || !v.isSecret || v.value === '')
    .map((v) => {
      if (v.isSecret && !includeSecrets) {
        return `${v.key}=# Add your secret here`
      }
      return `${v.key}=${v.value}`
    })

  return `# Environment Variables
# Generated by AI Website Builder
# Last updated: ${new Date().toISOString()}

${lines.join('\n')}
`
}

function generateSecureSecret(length = 32): string {
  return crypto.randomBytes(length).toString('hex')
}

function isSecretKey(key: string): boolean {
  const secretPatterns = [
    'SECRET',
    'KEY',
    'TOKEN',
    'PASSWORD',
    'PRIVATE',
    'API_KEY',
    'AUTH',
    'CREDENTIAL',
  ]
  const upperKey = key.toUpperCase()
  return secretPatterns.some((pattern) => upperKey.includes(pattern))
}

export function mergeEnvVariables(
  existing: EnvVariable[],
  updates: Partial<EnvVariable>[]
): EnvVariable[] {
  const merged = [...existing]

  for (const update of updates) {
    const index = merged.findIndex((v) => v.key === update.key)
    if (index >= 0) {
      merged[index] = { ...merged[index], ...update }
    } else if (update.key && update.value !== undefined) {
      merged.push({
        key: update.key,
        value: update.value,
        isSecret: update.isSecret ?? isSecretKey(update.key),
      })
    }
  }

  return merged
}
